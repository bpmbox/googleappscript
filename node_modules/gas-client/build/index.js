"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _uuid = require("uuid");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Util that returns true if allowedDevelopmentDomains matches origin
 * @param {string|function} allowedDevelopmentDomains either a string of space-separated allowed subdomains or a function that accepts the origin as an argument and returns true if permitted
 * @param {string} origin the target origin subdomain to compare against
 */
var checkAllowList = function checkAllowList(allowedDevelopmentDomains, origin) {
  if (typeof allowedDevelopmentDomains === 'string') {
    return allowedDevelopmentDomains.split(' ').some(function (permittedOrigin) {
      return permittedOrigin === origin;
    });
  }

  if (typeof allowedDevelopmentDomains === 'function') {
    return allowedDevelopmentDomains(origin) === true;
  }

  return false;
};

var Server =
/**
 * Accepts a single `config` object
 * @param {object} [config] An optional config object for use in development.
 * @param {string|function} [config.allowedDevelopmentDomains] An optional config to specify which domains are permitted for communication with Google Apps Script Webpack Dev Server development tool. This is a security setting, and if not specified, this will block functionality in development. Will accept either a space-separated string of allowed subdomains, e.g. `https://localhost:3000 http://localhost:3000` (notice no trailing slash); or a function that takes in the requesting origin should return `true` to allow communication, e.g. `(origin) => /localhost:\d+$/.test(origin)`
 */
function Server() {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, Server);

  // skip the reserved names: https://developers.google.com/apps-script/guides/html/reference/run
  var ignoredFunctionNames = ['withFailureHandler', 'withLogger', 'withSuccessHandler', 'withUserObject'];
  this.serverFunctions = {};

  try {
    // get the names of all of our publicly accessible server functions
    var functionNames = Object.keys(google.script.run).filter( // filter out the reserved names -- we don't want those
    function (functionName) {
      return !ignoredFunctionNames.includes(functionName);
    }); // attach Promise-based functions to the serverFunctions property

    functionNames.forEach(function (functionName) {
      _this.serverFunctions[functionName] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return new Promise(function (resolve, reject) {
          var _google$script$run$wi;

          (_google$script$run$wi = google.script.run.withSuccessHandler(resolve).withFailureHandler(reject))[functionName].apply(_google$script$run$wi, args);
        });
      };
    });
  } catch (err) {
    if (typeof google === 'undefined') {
      // we'll store and access the resolve/reject functions here by id
      window.gasStore = {}; // set up the message 'receive' handler

      var receiveMessageHandler = function receiveMessageHandler(event) {
        var allowedDevelopmentDomains = config.allowedDevelopmentDomains; // check the allow list for the receiving origin

        var allowOrigin = checkAllowList(allowedDevelopmentDomains, event.origin);
        if (!allowOrigin) return; // we only care about the type: 'RESPONSE' messages here

        if (event.data.type !== 'RESPONSE') return;
        var _event$data = event.data,
            response = _event$data.response,
            status = _event$data.status,
            id = _event$data.id; // look up the saved resolve and reject funtions in our global store based
        // on the response id, and call the function depending on the response status

        var _window$gasStore$id = window.gasStore[id],
            resolve = _window$gasStore$id.resolve,
            reject = _window$gasStore$id.reject;

        if (status === 'ERROR') {
          // TODO: return here so resolve doesn't get called on error
          reject(response);
        }

        resolve(response);
      };

      window.addEventListener('message', receiveMessageHandler, false);
      var handler = {
        get: function get(target, functionName) {
          var id = (0, _uuid.v4)();
          var promise = new Promise(function (resolve, reject) {
            // store the new Promise's resolve and reject
            window.gasStore[id] = {
              resolve: resolve,
              reject: reject
            };
          });
          return function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
            window.parent.postMessage({
              type: 'REQUEST',
              id: id,
              functionName: functionName,
              args: [].concat(args)
            }, // only send messages to our dev server, which should be running on the same origin
            window.location.origin);
            return promise;
          };
        }
      };
      this.serverFunctions = new Proxy({}, handler);
    }
  }
};

exports["default"] = Server;